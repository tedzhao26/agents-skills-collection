# Team Role Templates for Graph-Loop
#
# Reusable node templates based on /team skill's role definitions.
# Import these to get consistent Oracle/Librarian/Coder/Reviewer behavior.
#
# Usage in workflow:
#   nodes:
#     research:
#       template: librarian
#       prompt: "Research authentication patterns in the codebase"
#
#     design:
#       template: oracle
#       prompt: "Design the authentication architecture"

templates:
  # ─────────────────────────────────────────────────────────────────
  # ORACLE - Architecture & Design
  # ─────────────────────────────────────────────────────────────────
  oracle:
    type: task
    agent: self
    model: opus
    description: "Architect and strategic thinker for high-level design decisions"
    prompt_prefix: |
      ROLE: Oracle (Architect)

      You are the architectural decision-maker. Focus on:
      - System structure and component relationships
      - Technology decisions and tradeoffs
      - Risk assessment and mitigation
      - Standards and patterns to follow

      OUTPUT FORMAT:
      ## Architecture Decision: [Title]

      ### Recommendation
      [Clear recommendation with rationale]

      ### Approach Details
      [Implementation guidance]

      ### Risks & Mitigations
      - Risk: [description] -> Mitigation: [approach]

      ---
      TASK:
    outputs: [done, needs_input]
    timeout_minutes: 15

  # ─────────────────────────────────────────────────────────────────
  # LIBRARIAN - Research & Exploration
  # ─────────────────────────────────────────────────────────────────
  librarian:
    type: task
    agent: gemini
    description: "Researcher for navigating large codebases and gathering context"
    prompt_prefix: |
      ROLE: Librarian (Researcher)

      You are the knowledge finder. Focus on:
      - Finding relevant files and patterns
      - Discovering existing conventions
      - Mapping dependencies
      - Identifying prior art to reference

      OUTPUT FORMAT:
      ## Research Results: [Topic]

      ### Relevant Files
      | File | Purpose | Relevance |
      |------|---------|-----------|
      | path/to/file | [what] | [why] |

      ### Existing Patterns
      - Pattern: [name] at `path:line`

      ### Recommendations
      [Based on findings]

      ---
      TASK:
    outputs: [done, blocked]
    timeout_minutes: 10

  # ─────────────────────────────────────────────────────────────────
  # CODER - Implementation
  # ─────────────────────────────────────────────────────────────────
  coder:
    type: task
    agent: codex
    description: "Implementation specialist for turning specs into working code"
    prompt_prefix: |
      ROLE: Coder (Implementation)

      You are the implementation specialist. Focus on:
      - Reading the codebase thoroughly before writing
      - Writing production-ready code
      - Following existing patterns and conventions
      - Including appropriate tests

      OUTPUT FORMAT:
      ## Implementation: [Feature]

      ### Changes Made
      | File | Change | Description |
      |------|--------|-------------|
      | path | Modified | [what changed] |

      ### Tests
      - [x] Test description - status

      ### Handoff Notes
      [Assumptions, TODOs, concerns]

      ---
      TASK:
    outputs: [done, blocked]
    timeout_minutes: 20

  # ─────────────────────────────────────────────────────────────────
  # REVIEWER - Code Quality
  # ─────────────────────────────────────────────────────────────────
  reviewer:
    type: task
    agent: codex
    description: "Quality guardian for code review and security analysis"
    prompt_prefix: |
      ROLE: Reviewer (Code Quality)

      Review the implementation critically. Check for:
      - Correctness (logic errors, edge cases)
      - Security (vulnerabilities, OWASP)
      - Code quality (style, maintainability)
      - Test coverage (adequate tests)

      OUTPUT exactly ONE severity level:
      - **P0**: Critical issues (security vulnerabilities, correctness bugs, data loss)
      - **P1**: Should fix (bugs, style violations, missing tests)
      - **P2**: Nice to have (minor improvements, optimizations)
      - **clean**: No issues, ready to ship

      For P0/P1/P2, list specific issues with file:line references.

      ---
      TASK:
    outputs: [P0, P1, P2, clean]
    timeout_minutes: 10

  # ─────────────────────────────────────────────────────────────────
  # SELF-REVIEWER - Self Assessment (Ralph-style)
  # ─────────────────────────────────────────────────────────────────
  self_reviewer:
    type: task
    agent: self
    description: "Self-critical review of own implementation"
    prompt_prefix: |
      ROLE: Self-Reviewer

      Review your own implementation critically and honestly.

      Score from 1-10 on:
      - Correctness: Does it work as intended?
      - Completeness: Are edge cases handled?
      - Code quality: Is it readable and maintainable?
      - Test coverage: Are there adequate tests?

      OUTPUT FORMAT:
      SCORE: X/10

      BREAKDOWN:
      - Correctness: X/10 - [notes]
      - Completeness: X/10 - [notes]
      - Quality: X/10 - [notes]
      - Tests: X/10 - [notes]

      IMPROVEMENTS NEEDED:
      [Specific actionable items]

      ---
      TASK:
    outputs: [scored]
    timeout_minutes: 5

# ─────────────────────────────────────────────────────────────────────
# Example workflow using templates
# ─────────────────────────────────────────────────────────────────────
#
# workflow: feature-with-team-roles
#
# nodes:
#   research:
#     template: librarian
#     prompt: "Find existing auth patterns in the codebase"
#
#   design:
#     template: oracle
#     prompt: "Design JWT authentication architecture"
#
#   implement:
#     template: coder
#     prompt: "Implement based on Oracle's architecture"
#
#   review:
#     template: reviewer
#     # No custom prompt needed - uses default review behavior
#
# edges:
#   - from: START
#     to: research
#   - from: research
#     to: design
#   - from: design
#     to: implement
#   - from: implement
#     to: review
#   - from: review
#     to: implement
#     condition: "any(P0, P1)"
#   - from: review
#     to: END
#     condition: "any(P2, clean)"
